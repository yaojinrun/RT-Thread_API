<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>RT-Thread RTOS: 文件和目录</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RT-Thread RTOS
   &#160;<span id="projectnumber">3.1.0</span>
   </div>
   <div id="projectbrief">An open source embedded real-time operating system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li><a href="modules.html"><span>模块</span></a></li>
      <li><a href="annotated.html"><span>结构体</span></a></li>
      <li><a href="examples.html"><span>示例</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">函数</a>  </div>
  <div class="headertitle">
<div class="title">文件和目录<div class="ingroups"><a class="el" href="group___d_f_s.html">文件系统</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:ga94873fa89201b877351b663b9f5b040d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#ga94873fa89201b877351b663b9f5b040d">open</a> (const char *file, int flags,...)</td></tr>
<tr class="memdesc:ga94873fa89201b877351b663b9f5b040d"><td class="mdescLeft">&#160;</td><td class="mdescRight">打开文件  <a href="#ga94873fa89201b877351b663b9f5b040d">更多...</a><br /></td></tr>
<tr class="separator:ga94873fa89201b877351b663b9f5b040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafbcde67669a1b96577e735ddebd8634"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#gaafbcde67669a1b96577e735ddebd8634">close</a> (int fd)</td></tr>
<tr class="memdesc:gaafbcde67669a1b96577e735ddebd8634"><td class="mdescLeft">&#160;</td><td class="mdescRight">关闭文件  <a href="#gaafbcde67669a1b96577e735ddebd8634">更多...</a><br /></td></tr>
<tr class="separator:gaafbcde67669a1b96577e735ddebd8634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac327608bc25b32fe6b55aaa0d4bb3f44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#gac327608bc25b32fe6b55aaa0d4bb3f44">read</a> (int fd, void *buf, size_t len)</td></tr>
<tr class="memdesc:gac327608bc25b32fe6b55aaa0d4bb3f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">读取数据  <a href="#gac327608bc25b32fe6b55aaa0d4bb3f44">更多...</a><br /></td></tr>
<tr class="separator:gac327608bc25b32fe6b55aaa0d4bb3f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6556217b4010a1fa24d4171625cba2f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#ga6556217b4010a1fa24d4171625cba2f7">write</a> (int fd, const void *buf, size_t len)</td></tr>
<tr class="memdesc:ga6556217b4010a1fa24d4171625cba2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">写入数据  <a href="#ga6556217b4010a1fa24d4171625cba2f7">更多...</a><br /></td></tr>
<tr class="separator:ga6556217b4010a1fa24d4171625cba2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce7c2db9fdb6aec06afaf3cfc5979c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#ga2ce7c2db9fdb6aec06afaf3cfc5979c7">rename</a> (const char *old, const char *new)</td></tr>
<tr class="memdesc:ga2ce7c2db9fdb6aec06afaf3cfc5979c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">重命名  <a href="#ga2ce7c2db9fdb6aec06afaf3cfc5979c7">更多...</a><br /></td></tr>
<tr class="separator:ga2ce7c2db9fdb6aec06afaf3cfc5979c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cee068f32a919cdd638e0578c1e5f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#gaf3cee068f32a919cdd638e0578c1e5f8">unlink</a> (const char *pathname)</td></tr>
<tr class="memdesc:gaf3cee068f32a919cdd638e0578c1e5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除文件  <a href="#gaf3cee068f32a919cdd638e0578c1e5f8">更多...</a><br /></td></tr>
<tr class="separator:gaf3cee068f32a919cdd638e0578c1e5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac21b705a5ebd42c4c46363250ab817bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#gac21b705a5ebd42c4c46363250ab817bc">stat</a> (const char *file, struct stat *buf)</td></tr>
<tr class="memdesc:gac21b705a5ebd42c4c46363250ab817bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">取得状态  <a href="#gac21b705a5ebd42c4c46363250ab817bc">更多...</a><br /></td></tr>
<tr class="separator:gac21b705a5ebd42c4c46363250ab817bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1759a877da2f37512096f3a491e4112"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#gac1759a877da2f37512096f3a491e4112">fstat</a> (int fildes, struct <a class="el" href="group___fs_posix_api.html#gac21b705a5ebd42c4c46363250ab817bc">stat</a> *buf)</td></tr>
<tr class="memdesc:gac1759a877da2f37512096f3a491e4112"><td class="mdescLeft">&#160;</td><td class="mdescRight">取得文件状态  <a href="#gac1759a877da2f37512096f3a491e4112">更多...</a><br /></td></tr>
<tr class="separator:gac1759a877da2f37512096f3a491e4112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e7cc4d869f1acc169fc67468d21162"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#ga66e7cc4d869f1acc169fc67468d21162">fsync</a> (int fildes)</td></tr>
<tr class="memdesc:ga66e7cc4d869f1acc169fc67468d21162"><td class="mdescLeft">&#160;</td><td class="mdescRight">同步文件数据到存储设备  <a href="#ga66e7cc4d869f1acc169fc67468d21162">更多...</a><br /></td></tr>
<tr class="separator:ga66e7cc4d869f1acc169fc67468d21162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7af18cc5fa39f42a3be1bf1eb24119d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#gae7af18cc5fa39f42a3be1bf1eb24119d">statfs</a> (const char *path, struct statfs *buf)</td></tr>
<tr class="memdesc:gae7af18cc5fa39f42a3be1bf1eb24119d"><td class="mdescLeft">&#160;</td><td class="mdescRight">查询文件系统相关信息  <a href="#gae7af18cc5fa39f42a3be1bf1eb24119d">更多...</a><br /></td></tr>
<tr class="separator:gae7af18cc5fa39f42a3be1bf1eb24119d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga548e5b744ca2e97beb61ad7aa41114e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#ga548e5b744ca2e97beb61ad7aa41114e2">mkdir</a> (const char *path, mode_t mode)</td></tr>
<tr class="memdesc:ga548e5b744ca2e97beb61ad7aa41114e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建目录  <a href="#ga548e5b744ca2e97beb61ad7aa41114e2">更多...</a><br /></td></tr>
<tr class="separator:ga548e5b744ca2e97beb61ad7aa41114e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga570282ae7ba596263ec812b368d99b34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#ga570282ae7ba596263ec812b368d99b34">rmdir</a> (const char *pathname)</td></tr>
<tr class="memdesc:ga570282ae7ba596263ec812b368d99b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除目录  <a href="#ga570282ae7ba596263ec812b368d99b34">更多...</a><br /></td></tr>
<tr class="separator:ga570282ae7ba596263ec812b368d99b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1632d8c06c14f295c6d9407b7fec67af"><td class="memItemLeft" align="right" valign="top">DIR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#ga1632d8c06c14f295c6d9407b7fec67af">opendir</a> (const char *name)</td></tr>
<tr class="memdesc:ga1632d8c06c14f295c6d9407b7fec67af"><td class="mdescLeft">&#160;</td><td class="mdescRight">打开目录  <a href="#ga1632d8c06c14f295c6d9407b7fec67af">更多...</a><br /></td></tr>
<tr class="separator:ga1632d8c06c14f295c6d9407b7fec67af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7687571d2af8efd5153874ae6e678d9"><td class="memItemLeft" align="right" valign="top">struct dirent *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#gaa7687571d2af8efd5153874ae6e678d9">readdir</a> (DIR *d)</td></tr>
<tr class="memdesc:gaa7687571d2af8efd5153874ae6e678d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">读取目录  <a href="#gaa7687571d2af8efd5153874ae6e678d9">更多...</a><br /></td></tr>
<tr class="separator:gaa7687571d2af8efd5153874ae6e678d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf08168ca632ba3f9385aa53261ae63d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#gaaf08168ca632ba3f9385aa53261ae63d">telldir</a> (DIR *d)</td></tr>
<tr class="memdesc:gaaf08168ca632ba3f9385aa53261ae63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取目录流的读取位置  <a href="#gaaf08168ca632ba3f9385aa53261ae63d">更多...</a><br /></td></tr>
<tr class="separator:gaaf08168ca632ba3f9385aa53261ae63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58829cca160034015b3dddc17bb502ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#ga58829cca160034015b3dddc17bb502ab">seekdir</a> (DIR *d, off_t offset)</td></tr>
<tr class="memdesc:ga58829cca160034015b3dddc17bb502ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置下次读取目录的位置  <a href="#ga58829cca160034015b3dddc17bb502ab">更多...</a><br /></td></tr>
<tr class="separator:ga58829cca160034015b3dddc17bb502ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e6a89050229d246d07d9e17d57cb29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#ga08e6a89050229d246d07d9e17d57cb29">rewinddir</a> (DIR *d)</td></tr>
<tr class="memdesc:ga08e6a89050229d246d07d9e17d57cb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">重设目录流的读取位置为开头位置  <a href="#ga08e6a89050229d246d07d9e17d57cb29">更多...</a><br /></td></tr>
<tr class="separator:ga08e6a89050229d246d07d9e17d57cb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058e669d865116ec6419ea3a52207830"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#ga058e669d865116ec6419ea3a52207830">closedir</a> (DIR *d)</td></tr>
<tr class="memdesc:ga058e669d865116ec6419ea3a52207830"><td class="mdescLeft">&#160;</td><td class="mdescRight">关闭目录  <a href="#ga058e669d865116ec6419ea3a52207830">更多...</a><br /></td></tr>
<tr class="separator:ga058e669d865116ec6419ea3a52207830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6adc1f71f9027c8bdd8e88e8c843049"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fs_posix_api.html#gaa6adc1f71f9027c8bdd8e88e8c843049">access</a> (const char *path, int amode)</td></tr>
<tr class="memdesc:gaa6adc1f71f9027c8bdd8e88e8c843049"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查文件是否存在  <a href="#gaa6adc1f71f9027c8bdd8e88e8c843049">更多...</a><br /></td></tr>
<tr class="separator:gaa6adc1f71f9027c8bdd8e88e8c843049"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<h2 class="groupheader">函数说明</h2>
<a class="anchor" id="ga94873fa89201b877351b663b9f5b040d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>打开文件 </p>
<p>此函数是POSIX兼容版本，它将打开文件并根据指定的标志返回文件描述符。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>打开或创建的文件名 </td></tr>
    <tr><td class="paramname">flags</td><td>指定打开文件的方式</td></tr>
  </table>
  </dd>
</dl>
<p>当前支持的打开方式有以下几种：</p>
<table class="doxtable">
<tr>
<th>flags </th><th>描述  </th></tr>
<tr>
<td>O_RDONLY </td><td>只读方式打开 </td></tr>
<tr>
<td>O_WRONLY </td><td>只写方式打开 </td></tr>
<tr>
<td>O_RDWR </td><td>以读写方式打开 </td></tr>
<tr>
<td>O_CREAT </td><td>如果要打开的文件不存在，咋建立该文件 </td></tr>
<tr>
<td>O_APPEND </td><td>当读写文件时会从文件尾开始移动，也就是说写入的数据会以附加的方式添加到文件的尾部。 </td></tr>
</table>
<dl class="section return"><dt>返回</dt><dd>成功则返回打开文件的描述符序号, 失败则分会-1。 </dd></dl>

</div>
</div>
<a class="anchor" id="gaafbcde67669a1b96577e735ddebd8634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>关闭文件 </p>
<p>此函数是POSIX兼容版本，它将关闭指定的文件描述符。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td><a class="el" href="group___fs_posix_api.html#ga94873fa89201b877351b663b9f5b040d" title="打开文件 ">open()</a>函数所返回的文件描述字</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功 0，失败 -1。 </dd></dl>

</div>
</div>
<a class="anchor" id="gac327608bc25b32fe6b55aaa0d4bb3f44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>读取数据 </p>
<p>该函数函数接口会把参数fd 所指的文件的count 个字节传送到buf 指针所指的内存中， 文件的读写位置会随读取到的字节移动。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>文件描述字 </td></tr>
    <tr><td class="paramname">buf</td><td>读取数据将要写入的缓存地址指针 </td></tr>
    <tr><td class="paramname">len</td><td>预读取文件的字节数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>实际读取到的字节数。 有两种情况会返回0值，一是读取数据已到达文件结尾， 二是无可读取的数据（例如设定count为0）。 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6556217b4010a1fa24d4171625cba2f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>写入数据 </p>
<p>函数接口会把buf 指针所指向的内存中count 个字节写入到参数fd 所指的文件内， 文件的读写位置会写入的字节移动。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>文件描述字 </td></tr>
    <tr><td class="paramname">buf</td><td>预写入数据的地址指针 </td></tr>
    <tr><td class="paramname">len</td><td>预写入文件的字节数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>实际写入文件的字节数 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ce7c2db9fdb6aec06afaf3cfc5979c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>重命名 </p>
<p>该函数会将参数old 所指定的文件名称改为参数new 所指的文件名称。若newpath 所指定的文件已经存在，则该文件将会被覆盖。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">old</td><td>需更改的文件名 </td></tr>
    <tr><td class="paramname">new</td><td>更改成的文件名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>0 成功，-1 失败。</dd></dl>
<dl class="section note"><dt>注解</dt><dd>: 旧文件名和新文件名必须属于同一文件系统。 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3cee068f32a919cdd638e0578c1e5f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>删除文件 </p>
<p>该函数库删除指定目录下的文件。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathname</td><td>指定删除文件的绝对路径</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>0 成功，-1 失败。 </dd></dl>

</div>
</div>
<a class="anchor" id="gac21b705a5ebd42c4c46363250ab817bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct stat *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>取得状态 </p>
<p>调用此函数可获得文件状态。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>文件名 </td></tr>
    <tr><td class="paramname">buf</td><td>结构指针，指向获取文件状态的结构</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>0 成功，-1 失败。 </dd></dl>

</div>
</div>
<a class="anchor" id="gac1759a877da2f37512096f3a491e4112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fstat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fildes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group___fs_posix_api.html#gac21b705a5ebd42c4c46363250ab817bc">stat</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>取得文件状态 </p>
<p>该函数用来将参数fildes所指的文件状态，复制到参数buf所指的结构中(struct stat)。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">fildes</td><td>要检查的打开文件的文件描述符 </td></tr>
    <tr><td class="paramname">buf</td><td>struct stat结构体类型的变量</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功则返回0，失败返回-1。</dd></dl>
<dl class="section note"><dt>注解</dt><dd>本函数与 <a class="el" href="group___fs_posix_api.html#gac21b705a5ebd42c4c46363250ab817bc" title="取得状态 ">stat()</a> 函数相似，不同的是，它是作用于已打开的文件的文件描述符而不是文件名。 </dd></dl>

</div>
</div>
<a class="anchor" id="ga66e7cc4d869f1acc169fc67468d21162"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fsync </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fildes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>同步文件数据到存储设备 </p>
<p>该函数可以同步内存中所有已修改的文件数据到储存设备。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">fildes</td><td>文件描述词</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_EOK 同步文件成功，-RT_ERROR 同步文件失败 set to indicate the error. </dd></dl>

</div>
</div>
<a class="anchor" id="gae7af18cc5fa39f42a3be1bf1eb24119d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int statfs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct statfs *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>查询文件系统相关信息 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>需要查询信息的文件系统的文件路径名 </td></tr>
    <tr><td class="paramname">buf</td><td>用于储存文件系统相关信息的结构体指针</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_EOK 查询文件系统信息成功，-RT_ERROR 失败 </dd></dl>

</div>
</div>
<a class="anchor" id="ga548e5b744ca2e97beb61ad7aa41114e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mkdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>创建目录 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>目录的绝对地址 </td></tr>
    <tr><td class="paramname">mode</td><td>创建模式</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_EOK 创建成功，-RT_ERROR 失败 </dd></dl>

</div>
</div>
<a class="anchor" id="ga570282ae7ba596263ec812b368d99b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rmdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>删除目录 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathname</td><td>需要删除目录的绝对路径</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_EOK 目录删除成功，-RT_ERROR 失败 </dd></dl>

</div>
</div>
<a class="anchor" id="ga1632d8c06c14f295c6d9407b7fec67af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DIR* opendir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>打开目录 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>目录的绝对地址</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>打开文件成功，返回指向目录的DIR结构指针, 失败则返回 NULL。 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7687571d2af8efd5153874ae6e678d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dirent* readdir </td>
          <td>(</td>
          <td class="paramtype">DIR *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>读取目录 </p>
<p>该函数用来读取目录，每读取一次目录，目录流的指针位置将自动往后递推1个位置。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>目录路径名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>读取成功返回指向目录entry的结构体指针，NULL 则表示已经读到目录尾。 </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf08168ca632ba3f9385aa53261ae63d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long telldir </td>
          <td>(</td>
          <td class="paramtype">DIR *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取目录流的读取位置 </p>
<p>该函数函数的返回值记录着一个目录流的当前位置，此返回值代表距离目录文件开头的 偏移量，返回值返回下个读取位置。你可以在随后的seekdir() 函数调用中利用这个值 来重置目录扫描到当前位置。也就是说telldir() 函数可以和seekdir() 函数配合使用， 重新设置目录流的读取位置到指定的偏移量。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>目录路径名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>读取位置的偏移量 </dd></dl>

</div>
</div>
<a class="anchor" id="ga58829cca160034015b3dddc17bb502ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seekdir </td>
          <td>(</td>
          <td class="paramtype">DIR *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>设置下次读取目录的位置 </p>
<p>该函数用来设置参数dir目录流目前的读取位置，在调用readdir() 时便从此新位置开始读取。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>目录路径名 </td></tr>
    <tr><td class="paramname">offset</td><td>偏移值，距离本次目录的位移 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08e6a89050229d246d07d9e17d57cb29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rewinddir </td>
          <td>(</td>
          <td class="paramtype">DIR *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>重设目录流的读取位置为开头位置 </p>
<p>该函数可以用来设置 d 目录流目前的读取位置为目录流的初始位置。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>目录路径名 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga058e669d865116ec6419ea3a52207830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int closedir </td>
          <td>(</td>
          <td class="paramtype">DIR *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>关闭目录 </p>
<p>该函数用来关闭一个目录，该函数必须和opendir() 函数成对出现。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>目录路径名</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_EOK 目录关闭成功，-RT_ERROR 失败 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6adc1f71f9027c8bdd8e88e8c843049"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int access </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>amode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>检查文件是否存在 </p>
<p>该函数将根据amode中包含的位模式检查由path参数指向的路径名所指定的文件。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>指定的文件/目录路径. </td></tr>
    <tr><td class="paramname">amode</td><td>该值可以是要检查的访问权限（R_OK，W_OK，X_OK）或存在测试（F_OK）。</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>允许访问请求，则返回0; 否则返回-1。 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2018年 十月 25日 星期四 00:39:49 , 为 RT-Thread RTOS使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
