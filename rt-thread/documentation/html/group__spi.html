<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>RT-Thread RTOS: SPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RT-Thread RTOS
   &#160;<span id="projectnumber">3.1.0</span>
   </div>
   <div id="projectbrief">An open source embedded real-time operating system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li><a href="modules.html"><span>模块</span></a></li>
      <li><a href="annotated.html"><span>结构体</span></a></li>
      <li><a href="examples.html"><span>示例</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">函数</a>  </div>
  <div class="headertitle">
<div class="title">SPI<div class="ingroups"><a class="el" href="group___d_r_i_v_e_r.html">设备管理</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:ga819ded0df4aefcabf5d7b2a254ce415e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#ga819ded0df4aefcabf5d7b2a254ce415e">rt_spi_bus_register</a> (struct <a class="el" href="structrt__spi__bus.html">rt_spi_bus</a> *bus, const char *name, const struct <a class="el" href="structrt__spi__ops.html">rt_spi_ops</a> *ops)</td></tr>
<tr class="memdesc:ga819ded0df4aefcabf5d7b2a254ce415e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI 总线注册  <a href="#ga819ded0df4aefcabf5d7b2a254ce415e">更多...</a><br /></td></tr>
<tr class="separator:ga819ded0df4aefcabf5d7b2a254ce415e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab153eb02cfb523b4fdc4d40e79c96c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#ga1ab153eb02cfb523b4fdc4d40e79c96c">rt_spi_bus_attach_device</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device, const char *name, const char *bus_name, void *user_data)</td></tr>
<tr class="memdesc:ga1ab153eb02cfb523b4fdc4d40e79c96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">挂载 SPI 设备到总线上  <a href="#ga1ab153eb02cfb523b4fdc4d40e79c96c">更多...</a><br /></td></tr>
<tr class="separator:ga1ab153eb02cfb523b4fdc4d40e79c96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19faa07950f052fcd3fb2a0af26a2db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#ga19faa07950f052fcd3fb2a0af26a2db0">rt_spi_take_bus</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device)</td></tr>
<tr class="memdesc:ga19faa07950f052fcd3fb2a0af26a2db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取 SPI 总线  <a href="#ga19faa07950f052fcd3fb2a0af26a2db0">更多...</a><br /></td></tr>
<tr class="separator:ga19faa07950f052fcd3fb2a0af26a2db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7025986fe1543c10f23c776687dcf56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#gaa7025986fe1543c10f23c776687dcf56">rt_spi_release_bus</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device)</td></tr>
<tr class="memdesc:gaa7025986fe1543c10f23c776687dcf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">释放 SPI 总线  <a href="#gaa7025986fe1543c10f23c776687dcf56">更多...</a><br /></td></tr>
<tr class="separator:gaa7025986fe1543c10f23c776687dcf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee394d6fc071e0060608004feafd1bee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#gaee394d6fc071e0060608004feafd1bee">rt_spi_take</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device)</td></tr>
<tr class="memdesc:gaee394d6fc071e0060608004feafd1bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取 SPI 器件  <a href="#gaee394d6fc071e0060608004feafd1bee">更多...</a><br /></td></tr>
<tr class="separator:gaee394d6fc071e0060608004feafd1bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86c852bfaef894264800afd569ac66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#gac86c852bfaef894264800afd569ac66d">rt_spi_release</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device)</td></tr>
<tr class="memdesc:gac86c852bfaef894264800afd569ac66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">释放 SPI 器件  <a href="#gac86c852bfaef894264800afd569ac66d">更多...</a><br /></td></tr>
<tr class="separator:gac86c852bfaef894264800afd569ac66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga454653047b1964d01154a7657b675c2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#ga454653047b1964d01154a7657b675c2b">rt_spi_configure</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device, struct <a class="el" href="structrt__spi__configuration.html">rt_spi_configuration</a> *cfg)</td></tr>
<tr class="memdesc:ga454653047b1964d01154a7657b675c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI 总线配置  <a href="#ga454653047b1964d01154a7657b675c2b">更多...</a><br /></td></tr>
<tr class="separator:ga454653047b1964d01154a7657b675c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02064c17425153edcf867cf7710af10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#gae02064c17425153edcf867cf7710af10">rt_spi_send_then_recv</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device, const void *send_buf, <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> send_length, void *recv_buf, <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> recv_length)</td></tr>
<tr class="memdesc:gae02064c17425153edcf867cf7710af10"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI 发送一次数据后再接收一次数据  <a href="#gae02064c17425153edcf867cf7710af10">更多...</a><br /></td></tr>
<tr class="separator:gae02064c17425153edcf867cf7710af10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6e4ea6c445fdca36f299dae7bd69ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#ga5f6e4ea6c445fdca36f299dae7bd69ae">rt_spi_send_then_send</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device, const void *send_buf1, <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> send_length1, const void *send_buf2, <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> send_length2)</td></tr>
<tr class="memdesc:ga5f6e4ea6c445fdca36f299dae7bd69ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI 连续发送两次数据  <a href="#ga5f6e4ea6c445fdca36f299dae7bd69ae">更多...</a><br /></td></tr>
<tr class="separator:ga5f6e4ea6c445fdca36f299dae7bd69ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga915185f522e978bcdcb76d113462cb0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#ga915185f522e978bcdcb76d113462cb0b">rt_spi_transfer</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device, const void *send_buf, void *recv_buf, <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> length)</td></tr>
<tr class="memdesc:ga915185f522e978bcdcb76d113462cb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI 单个消息传输  <a href="#ga915185f522e978bcdcb76d113462cb0b">更多...</a><br /></td></tr>
<tr class="separator:ga915185f522e978bcdcb76d113462cb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21dae313bb9a0faf840ad1b42ccff62b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrt__spi__message.html">rt_spi_message</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#ga21dae313bb9a0faf840ad1b42ccff62b">rt_spi_transfer_message</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device, struct <a class="el" href="structrt__spi__message.html">rt_spi_message</a> *message)</td></tr>
<tr class="memdesc:ga21dae313bb9a0faf840ad1b42ccff62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI 多个消息连续传输  <a href="#ga21dae313bb9a0faf840ad1b42ccff62b">更多...</a><br /></td></tr>
<tr class="separator:ga21dae313bb9a0faf840ad1b42ccff62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf73c4e6ac2190b3360045945fe898271"><td class="memItemLeft" align="right" valign="top">rt_inline <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#gaf73c4e6ac2190b3360045945fe898271">rt_spi_recv</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device, void *recv_buf, <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> length)</td></tr>
<tr class="memdesc:gaf73c4e6ac2190b3360045945fe898271"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI 消息接收函数  <a href="#gaf73c4e6ac2190b3360045945fe898271">更多...</a><br /></td></tr>
<tr class="separator:gaf73c4e6ac2190b3360045945fe898271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d272f7d685a4dc19b2bca56c192d817"><td class="memItemLeft" align="right" valign="top">rt_inline <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#ga8d272f7d685a4dc19b2bca56c192d817">rt_spi_send</a> (struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *device, const void *send_buf, <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> length)</td></tr>
<tr class="memdesc:ga8d272f7d685a4dc19b2bca56c192d817"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI 消息接收函数  <a href="#ga8d272f7d685a4dc19b2bca56c192d817">更多...</a><br /></td></tr>
<tr class="separator:ga8d272f7d685a4dc19b2bca56c192d817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ed1148c095fdc28bec6f57c40c0245"><td class="memItemLeft" align="right" valign="top">rt_inline void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__spi.html#ga33ed1148c095fdc28bec6f57c40c0245">rt_spi_message_append</a> (struct <a class="el" href="structrt__spi__message.html">rt_spi_message</a> *list, struct <a class="el" href="structrt__spi__message.html">rt_spi_message</a> *message)</td></tr>
<tr class="memdesc:ga33ed1148c095fdc28bec6f57c40c0245"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI 消息追加  <a href="#ga33ed1148c095fdc28bec6f57c40c0245">更多...</a><br /></td></tr>
<tr class="separator:ga33ed1148c095fdc28bec6f57c40c0245"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<h2 class="groupheader">函数说明</h2>
<a class="anchor" id="ga819ded0df4aefcabf5d7b2a254ce415e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a> rt_spi_bus_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__bus.html">rt_spi_bus</a> *&#160;</td>
          <td class="paramname"><em>bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrt__spi__ops.html">rt_spi_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI 总线注册 </p>
<p>调用此函数可以向系统中注册 SPI 总线。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">bus</td><td>SPI 总线句柄 </td></tr>
    <tr><td class="paramname">name</td><td>SPI 总线名称，一般与硬件控制器名称一致，如：”spi0” </td></tr>
    <tr><td class="paramname">ops</td><td>SPI 总线操作方法，即 SPI 驱动的实现</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_EOK 成功；-RT_ERROR bus 为空或者 name 已被注册。 </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ab153eb02cfb523b4fdc4d40e79c96c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a> rt_spi_bus_attach_device </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bus_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>挂载 SPI 设备到总线上 </p>
<p>此函数用于挂载一个SPI设备节点到指定的SPI总线，并内核注册SPI设备节点，并将user_data保存到SPI设备节点的user_data指针里。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 设备句柄 </td></tr>
    <tr><td class="paramname">name</td><td>SPI 设备名称 </td></tr>
    <tr><td class="paramname">bus_name</td><td>SPI 总线名称 </td></tr>
    <tr><td class="paramname">user_data</td><td>用户数据指针</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_EOK 成功；-RT_ERROR bus_name 不存在、device 为空、name 已被注册。 </dd></dl>

</div>
</div>
<a class="anchor" id="ga19faa07950f052fcd3fb2a0af26a2db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a> rt_spi_take_bus </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取 SPI 总线 </p>
<p>用户调用此函数来获取SPI总线，并设置SPI总线的工作模式和参数。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 总线设备句柄</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功则返回RT_EOK；错误则返回 错误码。 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7025986fe1543c10f23c776687dcf56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a> rt_spi_release_bus </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>释放 SPI 总线 </p>
<p>用户可以调用此函数来释放SPI总线。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 总线设备句柄</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功则返回RT_EOK；错误则返回 错误码。 </dd></dl>

</div>
</div>
<a class="anchor" id="gaee394d6fc071e0060608004feafd1bee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a> rt_spi_take </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取 SPI 器件 </p>
<p>调用此函数可以片选SPI设备。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 总线设备句柄</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>0 获取成功，片选开始。 </dd></dl>

</div>
</div>
<a class="anchor" id="gac86c852bfaef894264800afd569ac66d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a> rt_spi_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>释放 SPI 器件 </p>
<p>调用此函数可以释放被片选SPI设备。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 总线设备句柄</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>0 释放成功，片选结束。 </dd></dl>

</div>
</div>
<a class="anchor" id="ga454653047b1964d01154a7657b675c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a> rt_spi_configure </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__configuration.html">rt_spi_configuration</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI 总线配置 </p>
<p>本函数用于配置SPI BUS以满足不同设备的时钟、数据宽度等要求，通常需要配置SPI模式、频率参数。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 设备句柄 </td></tr>
    <tr><td class="paramname">cfg</td><td>SPI 传输配置参数指针 </td></tr>
    <tr><td class="paramname">device</td><td>SPI 设备句柄</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_EOK 配置成功。 </dd></dl>

</div>
</div>
<a class="anchor" id="gae02064c17425153edcf867cf7710af10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a> rt_spi_send_then_recv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>send_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a>&#160;</td>
          <td class="paramname"><em>send_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recv_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a>&#160;</td>
          <td class="paramname"><em>recv_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI 发送一次数据后再接收一次数据 </p>
<p>本函数适合从SPI外设中读取一块数据，本函数中会先发送一些数据（如命令和地址），然后再接收指定长度的数据。此函数等同于调用rt_spi_transfer_message()传输2条消息。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 总线设备句柄 </td></tr>
    <tr><td class="paramname">send_buf</td><td>发送缓冲区数据指针 </td></tr>
    <tr><td class="paramname">send_length</td><td>发送缓冲区数据字节数 </td></tr>
    <tr><td class="paramname">recv_buf</td><td>接收缓冲区数据指针，spi 是全双工的，支持同时收发 </td></tr>
    <tr><td class="paramname">recv_length</td><td>接收缓冲区数据字节数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_EOK 成功，-RT_EIO 失败。 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f6e4ea6c445fdca36f299dae7bd69ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___basic_def.html#ga42df42aabf676f2a89f5af2208b79950">rt_err_t</a> rt_spi_send_then_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>send_buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a>&#160;</td>
          <td class="paramname"><em>send_length1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>send_buf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a>&#160;</td>
          <td class="paramname"><em>send_length2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI 连续发送两次数据 </p>
<p>本函数适合向SPI外设中写入一块数据，本函数中会先发送一些数据（如命令和地址），然后再发送指定长度的数据。此函数等同于调用rt_spi_transfer_message()传输2条消息。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 总线设备句柄 </td></tr>
    <tr><td class="paramname">send_buf1</td><td>发送缓冲区1数据指针 </td></tr>
    <tr><td class="paramname">send_length1</td><td>发送缓冲区1数据字节数 </td></tr>
    <tr><td class="paramname">send_buf2</td><td>发送缓冲区2数据指针 </td></tr>
    <tr><td class="paramname">send_length2</td><td>发送缓冲区2数据字节数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_EOK 成功，-RT_EIO 失败。 </dd></dl>

</div>
</div>
<a class="anchor" id="ga915185f522e978bcdcb76d113462cb0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> rt_spi_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>send_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recv_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI 单个消息传输 </p>
<p>调用此函数将发送一次数据，同于调用rt_spi_transfer_message()传输一条消息。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 设备句柄 </td></tr>
    <tr><td class="paramname">send_buf</td><td>发送缓冲区指针 </td></tr>
    <tr><td class="paramname">recv_buf</td><td>接收缓冲区指针 </td></tr>
    <tr><td class="paramname">length</td><td>发送 / 接收 数据字节数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>实际传输的字节数 </dd></dl>

</div>
</div>
<a class="anchor" id="ga21dae313bb9a0faf840ad1b42ccff62b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrt__spi__message.html">rt_spi_message</a>* rt_spi_transfer_message </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__message.html">rt_spi_message</a> *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI 多个消息连续传输 </p>
<p>此函数可以传输一连串消息，用户可以很灵活的设置message结构体各参数的数值，从而可以很方便的控制数据传输方式。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 设备句柄 </td></tr>
    <tr><td class="paramname">message</td><td>消息指针</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>RT_NULL 消息列表发送成功，发送失败则返回当前的消息指针。 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf73c4e6ac2190b3360045945fe898271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_inline <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> rt_spi_recv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>recv_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI 消息接收函数 </p>
<p>调用此函数接受数据并保存到recv_buf指向的缓冲区。是对rt_spi_transfer()函数的封装。 SPI协议里面只能由MASTER主动产生时钟，因此，在接收数据时，会发送dummy。此函数等同于 调用rt_spi_transfer_message()传输一条消息。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 设备句柄 </td></tr>
    <tr><td class="paramname">recv_buf</td><td>接收缓冲区指针 </td></tr>
    <tr><td class="paramname">length</td><td>接受数据的字节数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>实际接收的字节数。 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d272f7d685a4dc19b2bca56c192d817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_inline <a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> rt_spi_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__device.html">rt_spi_device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>send_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___basic_def.html#ga8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI 消息接收函数 </p>
<p>调用此函数发送send_buf指向的缓冲区的数据，忽略接收到的数据。是对rt_spi_transfer()函数的封装。 此函数等同于调用rt_spi_transfer_message()传输一条消息。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>SPI 设备句柄 </td></tr>
    <tr><td class="paramname">send_buf</td><td>发送缓冲区指针 </td></tr>
    <tr><td class="paramname">length</td><td>发送数据的字节数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>实际发送的字节数。 </dd></dl>

</div>
</div>
<a class="anchor" id="ga33ed1148c095fdc28bec6f57c40c0245"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_inline void rt_spi_message_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__message.html">rt_spi_message</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrt__spi__message.html">rt_spi_message</a> *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI 消息追加 </p>
<p>调用此函数可以向SPI消息发送链表中增加一条消息。</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>消息链表指针 </td></tr>
    <tr><td class="paramname">message</td><td>消息指针 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
生成于 2018年 十月 25日 星期四 00:39:49 , 为 RT-Thread RTOS使用  &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
